syntax checkers are puppet-lint & puppet parser validate

access facts using facter command 
facter interfaces 2>/dev/null
lo0_2,vnet1_2

facter os
{
  architecture => "x86_64",
  distro => {
    codename => "Tikanga",
    description => "Red Hat Enterprise Linux Server release 5.11 (Tikanga)",
    id => "RedHatEnterpriseServer",
    release => {
      full => "5.11",
      major => "5",
      minor => "11"
    },
    specification => ":core-4.0-amd64:core-4.0-ia32:core-4.0-noarch:graphics-4.0-amd64:graphics-4.0-ia32:graphics-4.0-noarch:printing-4.0-amd64:printing-4.0-ia32:printing-4.0-noarch"
  },
  family => "RedHat",
  hardware => "x86_64",
  name => "RedHat",
  release => {
    full => "5.11",
    major => "5",
    minor => "11"
  },
  selinux => {
    enabled => false
  }
}

facter os.family
facter release.full
############################################################################################################################
had to give full DNS name of master in slave config for -tv to pull down catalogs 
[main]
 certname = puppet-slave
 server = puppet-master.us-central1-a.c.linen-sun-264712.internal
 environment = production
 runinterval = 1h


########################################################################################################################

vi hello.pp  - puppet apply hello.pp - to compile it into a catalog

metaparameters are before/require/notify/subscribe  -> capitalize the resource ie require => File['/tmp/file']

modules = {manifests}

including custom modules for puppet -> puppet apply --modulepath /root/mpli/modules -e 'include examples'  ( he starts right here with OOPs)

class can have a init.pp file which runs everytime above apply command is executed like a constructor.
include package::manifest   

Using .erb extension for templatng <%  ruby-code-in-here   %>

###################################################################################################################################

Create another subclass that creates a file and another that uses a template.
example::file
# example::file
class example::file {
  file { 'source-file':
    path => '/tmp/example-file',
    source => 'puppet:///modules/example/example-file',
  }
}

example::template
This is an example template
Facts are available using @
This nodes hostname is <%= @hostname %>
This node has the following interfaces:
<% @interfaces.split(',').each do |interface| -%>   ## - for not adding a newline 
  <%= interface %>
<% end -%>
Done.

class example::template {
 file {'example-template':
   path    => '/tmp/example-template',
   content => template('example/example-template.erb')
 }
}


####################################################################################################################################

default port : 8140

for environments , /etc/puppetlabs/code/environments/  default production 

r10k automates the git part   use gem install 


create_resources

This is the create_resources module.

*NOTE* - this has been accepted into 2.7.x core, I am publishing it seperately 
so that it can be used with 2.6.x

  This function allows you to dynamically generate resources,
  passing them as a hash to the create_resources function.
  
  This was originally written to be used together with an ENC.
  
  Resources can be programitally generated as yaml and passed to a class.
  
  classes:
    webserver::instances:
      instances:
        instance1:
          foo: bar
        instance2:
          foo: blah
  
  Then puppet code can consume the hash parameters and convert then into resources
  
  class webserver::instances (
    $instances = {}
  ) {
    create_resources('webserver::instance', $instances)
  }
  
  Now I can dynamically determine how webserver instances are deployed to nodes
  by updating the YAML files.
  
  
  ###############################################################################################################################
  
  create_resources will just map

# A hash of user resources:
$myusers = {
  'nick' => { uid    => '1330',
              gid    => allstaff,
              groups => ['developers', 'operations', 'release'], },
  'dan'  => { uid    => '1308',
              gid    => allstaff,
              groups => ['developers', 'prosvc', 'release'], },
}

create_resources(user, $myusers)
into

  user{'nick':
    uid    => '1330',
    gid    => allstaff,
    groups => ['developers', 'operations', 'release'], },
  }
  user{'dan':
    uid    => '1308',
    gid    => allstaff,
    groups => ['developers', 'prosvc', 'release'], },
  }
So those users will be passed to user provider. You can test it easily creating a users.pp file with your recipes, and testing it with puppet apply --noop :

# puppet apply --noop users.pp 
Notice: Compiled catalog for yourfqdn in environment production in 0.15 seconds
Notice: /Stage[main]/Main/User[nick]/ensure: current_value absent, should be present (noop)
Notice: /Stage[main]/Main/User[dan]/ensure: current_value absent, should be present (noop)
Notice that if users already exist, puppet apply wont do anything

shareimprove this answer
edited Dec 9 '14 at 8:08

########################################################################################################################################


