

df -i .   ---> find . -xdev -empty -print |wc -l


By default, you can always list other users processes in Linux.

To change that, you need to mount proc in /etc/fstab with hidepid=2:

proc            /proc           proc    defaults,hidepid=2
This functionality is supported from the kernel v3.2 onwards. It hides /proc and consequentially ps activity from all users except root.


To check if Pdftk is already installed

sudo apt list | grep pdftk 

If output contains '[installed]' tag with pdftk then you can skip step1 i.e if the output is like this

qpdf -password=<your-password> -decrypt /path/to/secured.pdf out.pdf

########################################################################################################

As the day proceeds there comes a lot of work. I am listing a few, it may differ from organization to organization.

    Commissioning and decommissioning of resources as per the need.
    Disk management
    user and access management
    build and release management
    configuration management
    troubleshooting applications issues
    scanning through endless lines of log
    having project meetings
    keep an eye on server and application health
    keeping in check the various components of your infrastructure ensuring the maximum uptime.
    
    
    etup Linux OS Virtual/on-premises Server as per the requirement from Dev team.

    Set repository and Install packages and update to its stable version without losing any data.
    Create, Delete and modify user and groups
    Must be comfortable with CLI, and perform a major task using CLI.
    Manage file system permissions for users and groups and apply system policy.
    Must be aware of all system configuration file and keep a backup of it.
    File sharing for Windows and Linux ( samba, NFS )
    Should be able to work remotely without GUI and understating of SSH.
    Must have good knowledge of shell scripts, without shell scripting you canâ€™t be a good system admin.
    Keep a record of changes and able to solve the problem quickly.
    
    ######################################################################################################
    
    Steps to install the s3fs on Centos/RHEL/Amazon Linux
Login to EC2 Linux Server via SSH

Install required dependencies for Centos/RHEL/Amazon Linux
$ sudo yum install automake fuse fuse-devel gcc-c++ git libcurl-devel libxml2-devel make openssl-devel
1
	
$ sudo yum install automake fuse fuse-devel gcc-c++ git libcurl-devel libxml2-devel make openssl-devel

#For Ubuntu Systems

$ sudo apt-get install build-essential libcurl4-openssl-dev libxml2-dev mime-support
1
	
$ sudo apt-get install build-essential libcurl4-openssl-dev libxml2-dev mime-support

Now compile s3fs and install it with below command:

# git clone https://github.com/s3fs-fuse/s3fs-fuse.git
# cd s3fs-fuse
# ./autogen.sh
# ./configure
# make
# sudo make install
1
2
3
4
5
6
	
# git clone https://github.com/s3fs-fuse/s3fs-fuse.git
# cd s3fs-fuse
# ./autogen.sh
# ./configure
# make
# sudo make install

Step to mount S3 Bucket to Linux File System

You need root privileges, so login with root user or switch to root user:
$ sudo su
1
	
$ sudo su

Create IAM user you need access-key and secret key for s3fs, store key details in /etc/passwd-s3fs

#echo <access-key-id>:<secret-access-key> > /etc/passwd-s3fs

#chmod 600 /etc/passwd-s3fs
1
2
3
	
#echo <access-key-id>:<secret-access-key> > /etc/passwd-s3fs
 
#chmod 600 /etc/passwd-s3fs

(Replace <access-key-id> and <secret-access-key> with the actual IAM user keys)
Create Dir to mount s3bucket:

For example:
#mkdir /mnt/<test-bucket>
Add entry to fstab to mount the bucket:
echo s3fs#<s3-bucket> /mnt/<test-bucket> fuse _netdev,rw,nosuid,nodev,allow_other,nonempty 0 0 >> /etc/fstab
1
2
3
	
#mkdir /mnt/<test-bucket>
Add entry to fstab to mount the bucket:
echo s3fs#<s3-bucket> /mnt/<test-bucket> fuse _netdev,rw,nosuid,nodev,allow_other,nonempty 0 0 >> /etc/fstab

(Replace the leading <s3-bucket> with your AWS s3 bucket name and the /mnt/<test-bucket> with the mount point which you have created)

Use-mention command to mount the partition which has entered in fstab and here we just now added AWS S3 bucket details to mount on Linux:
# mount -a
1
	
# mount -a

Verify the S3 bucket mounted on Linux server

# df -h
1
	
# df -h

In the command output, you can see the bucket name which you have to add an entry in /etc/fstab.



When a child exits, some process must wait on it to get its exit code. That exit code is stored in the process table until this happens.
The act of reading that exit code is called "reaping" the child. Between the time a child exits and is reaped, it is called a zombie. 
(The whole nomenclature is a bit gruesome when you think about it; I recommend not thinking about it too much.)

Zombies only occupy space in the process table. They take no memory or CPU. However, the process table is a finite resource, and
excessive zombies can fill it, meaning that no other processes can launch. Beyond that, they are bothersome clutter, and should be
strongly avoided.

If a process exits with children still running (and doesn't kill its children; the metaphor continues to be bizarre), those 
children are orphans. Orphaned children are immediately "adopted" by init (actually, I think most people call this "reparenting,"
but "adoption" seems to carry the metaphor better). An orphan is just a process. It will use whatever resources it uses. It is 
reasonable to say that it is not an "orphan" at all since it has a parent, but I've heard them called that often.

init automatically reaps its children (adopted or otherwise). So if you exit without cleaning up your children, then they will not
become zombies (at least not for more than a moment).

But long-lived zombies exist. What are they? They're the former children of an existing process that hasn't reaped them. The
process may be hung. Or it may be poorly written and forgets to reap its children. Or maybe it's overloaded and hasn't gotten 
around to it. Or whatever. But for some reason, the parent process continues to exist (so they aren't orphans), and they haven't 
been waited on, so they live on as zombies in the process table.

So if you see zombies for longer than a moment, then it means that there is something wrong with the parent process, and something 
should be done to improve that program



################################################################################################################

The zombie (child died - parent alive)isn't occupying any significant memory or resources, it's (effectively) only an exit status waiting to be delivered.
An orphan is a live, running process just like any other -- it just has a peculiar name (parent died - child alive)

    
