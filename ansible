- name: Ensure Ansible user is present (RedHat)
  user:
   name: ansible
   comment: "ansible user created by bootstrap playbook"
   generate_ssh_key: yes
   groups: wheel
 tags:
 - bootstrap
 when: ansible_os_family=="RedHat"

- name: Ensure Ansible user is present (Debian)
  user:
   name: ansible
   comment: "ansible user created by bootstrap playbook"
   generate_ssh_key: yes
   groups: sudo
  tags:
  - bootstrap
  when: ansible_os_family=="Debian"

- name: update sudoers to ensure ansible user can sudo
  lineinfile:
    dest: /etc/sudoers
    state: present
    regexp: '^ansible'
    line: 'ansible ALL=(ALL) NOPASSWD: ALL'
  tags:
  - bootstrap
  
  ###############################################################################################################
  
  How do I skip a play in an Ansible playbook ?

This is done using the conditional execution using when

################################################################################################################

Facts

These are variables that contain information pertinent to the current host (inventory_hostname). They are only available if gathered first.

ansible_facts Contains any facts gathered or cached for the inventory_hostname Facts are normally gathered by the setup module automatically in a play, but any module can return facts.

ansible_local Contains any ‘local facts’ gathered or cached for the inventory_hostname. The keys available depend on the custom facts created. See the setup module for more details.

As an example:

ansible -i localhost, all -c local -m setup -a filter=*swap*
localhost | SUCCESS => {
    "ansible_facts": {
        "ansible_swapfree_mb": 437,
        "ansible_swaptotal_mb": 979
    },
    "changed": false
}
In your playbook your task to reset swap should then have the conditional like:

when: ansible_swap_free_mb < 500

In your case, however you  want to trigger on swap used, so you would have to compute the difference between total and free.

################################################################################################################

---
- hosts: hostnametest
  tasks:
   - name: we take swap space used (megabytes)
     shell : free -m | grep Swap | awk '{print $3}'
     register: swap_used

   - name: Turn off swap
     shell: "swapoff -a"
     when: (swap_used.stdout_lines[0] | int) > 100

   - name: Turn on swap
     shell: "swapon -a"
     when: (swap_used.stdout_lines[0] | int) > 100
     
     
   ##############################################################################################################
   
    - name: run script
   shell: runuser -l testuser -c "/tmp/test.sh"
   register: myshell_output
 - name: copy output to a local file
   lineinfile:
     dest: /thesaurus/output
     line: "{{ item }}"
     insertafter: EOF
   with_items:
    - "#####################Beginning##########################"
    - "{{ myshell_output.stdout }}"
    - "########################END#############################"
   delegate_to: localhost
   
   
    This can be done with either of the

tree or
log_plays
modules.

I would probably suggest the log_plays module in your case.


#########################################################################################################

- hosts: localhost

  tasks:
  - name: Test that my hello_world module works
    hello_world: 
    register: result

  - debug: var=result  
  
  
  Create library directory with a python file in the root of your project
hello_world.yml
[library]
   |_ hello_world.py
Add the following content to the hello_world.py


#!/usr/bin/python

from ansible.module_utils.basic import *

def main():
    module = AnsibleModule(argument_spec={})
    theReturnValue = {"hello": "world"}
    module.exit_json(changed=False, meta=theReturnValue)

if __name__ == '__main__':
    main()
    
    
    ###################################################################################################################
    
    - hosts: localhost

  tasks:
  - name: Test that my change_version module works
    version_change: 
      version_name: "Before"
      version_no:  1.1.1 
      unchanged_value: "This will pass through"
    register: result

  - debug: var=result 
  
  
  
  
  #!/usr/bin/python

from ansible.module_utils.basic import *

def main():

    fields = {
        "version_no": {"default": True, "type": "str"},
        "version_name": {"default": True, "type": "str"},
        "unchanged_value": {"default": True, "type": "str"}
    }

    module = AnsibleModule(argument_spec=fields)
    # change the name
    module.params.update({"version_name": "After"})
    # bump minor and patch version
    mylist = module.params["version_no"].split('.')
    mylist[2] = str(int(mylist[2]) + 2)
    mylist[1] = str(int(mylist[1]) + 1)
    mystr= '.'.join(mylist)
    module.params.update({"version_no": mystr})

    
    module.exit_json(changed=True, meta=module.params)


if __name__ == '__main__':
    main()
    
    #######################################################################################################################
    
    The Basics of Creating an Ansible Module
Here we will show you some of the must-follow basics steps to make a custom Ansible module.

Use common aliases across modules – name, src, dest, state
Modules should only be one file. If you need multiple files, you’re looking to make an action plugin not a module.
Modules should only return JSON; it shouldn’t be giving any errors or tracebacks.
All modules need to start with a shebang!

########################################################################################################################

Here are some basic considerations of writing Ansible modules:

Ansible will look in the library directory relative to the playbook, for example: playbooks/library/your-module
You can also specify the path to your custom modules in ansible.cfg, for example: library = /usr/share/ansible
Ansible expects modules to return JSON, for example: {'changed': false, 'failed': true, 'msg': 'could not reach the host'}
If you write your module in Python (it can be written in any language as long as it returns json) you can import Ansible helper libraries
If are using Python try to limit the libraries you are using to the standard library. If that’s not possible you need a strategy to install those libraries everywhere you will run the playbooks (preferably with your Linux distributions package manager and not pip ;) )
Good practice is to write a multi-line at the start of your module describing parameters and how to run it. This is especially important if you want to open source it.

################################################################################################################################




